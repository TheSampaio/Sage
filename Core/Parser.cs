using Sage.Ast;
using Sage.Enums;
using Sage.Interfaces;
using Sage.Utilities;

namespace Sage.Core
{
    /// <summary>
    /// Implements a recursive descent parser to convert a stream of tokens into an Abstract Syntax Tree (AST).
    /// Maintains strict operator precedence and semantic correctness during the transformation.
    /// </summary>
    /// <param name="tokens">The list of tokens generated by the Lexer.</param>
    public class Parser(List<Token> tokens) : IParser
    {
        private readonly List<Token> _tokens = tokens;
        private int _pos = 0;

        /// <summary>
        /// Gets the current token in the stream, or the EOF token if at the end.
        /// </summary>
        private Token Current => _pos < _tokens.Count ? _tokens[_pos] : _tokens[^1];

        /// <summary>
        /// Consumes a token of a specific type. Throws a standardized CompilerException on mismatch.
        /// </summary>
        /// <param name="type">The expected TokenType.</param>
        /// <param name="errorMessage">Optional custom error message.</param>
        /// <returns>The consumed Token.</returns>
        private Token Consume(TokenType type, string errorMessage = "")
        {
            if (Current.Type == type)
            {
                var t = Current;
                _pos++;
                return t;
            }

            string msg = string.IsNullOrEmpty(errorMessage)
                ? $"Expected {type} but found {Current.Type} ('{Current.Value}')"
                : errorMessage;

            throw new CompilerException(Current, "S001", msg);
        }

        /// <summary>
        /// Checks if the current token matches a type and advances the pointer if true.
        /// </summary>
        private bool Match(TokenType type)
        {
            if (Current.Type == type)
            {
                _pos++;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Main entry point for parsing the token stream into a complete ProgramNode.
        /// </summary>
        public ProgramNode Parse()
        {
            var program = new ProgramNode();
            while (Current.Type != TokenType.EndOfFile)
            {
                if (Current.Type == TokenType.Keyword_Module)
                    program.Statements.Add(ParseModule());
                else
                    program.Statements.Add(ParseStatement());
            }
            return program;
        }

        private ModuleNode ParseModule()
        {
            Consume(TokenType.Keyword_Module);
            string name = Consume(TokenType.Identifier).Value;
            Consume(TokenType.OpenBrace);

            var module = new ModuleNode(name);
            while (Current.Type != TokenType.CloseBrace && Current.Type != TokenType.EndOfFile)
            {
                if (Current.Type == TokenType.Keyword_Func)
                    module.Functions.Add(ParseFunction(module.Name));
                else
                    throw new CompilerException(Current, "S002", "Only functions are supported in modules.");
            }

            Consume(TokenType.CloseBrace);
            return module;
        }

        private AstNode ParseStatement()
        {
            if (Match(TokenType.Keyword_Use))
            {
                string name = Consume(TokenType.Identifier).Value;
                Consume(TokenType.Semicolon);
                return new UseNode(name);
            }

            if (Current.Type == TokenType.Keyword_Func) return ParseFunction("");

            if (Match(TokenType.Keyword_Return))
            {
                var expr = ParseExpression();
                Consume(TokenType.Semicolon);
                return new ReturnNode(expr);
            }

            if (Current.Type == TokenType.Keyword_Var || Current.Type == TokenType.Keyword_Const)
                return ParseVariableDeclaration();

            if (Current.Type == TokenType.Keyword_If) return ParseIfStatement();
            if (Current.Type == TokenType.Keyword_While) return ParseWhileStatement();
            if (Current.Type == TokenType.Keyword_For) return ParseForStatement();

            var exprStmt = ParseExpression();
            Consume(TokenType.Semicolon);
            return new ExpressionStatementNode(exprStmt);
        }

        private VariableDeclarationNode ParseVariableDeclaration()
        {
            bool isConst = Match(TokenType.Keyword_Const);
            if (!isConst) Consume(TokenType.Keyword_Var);

            string name = Consume(TokenType.Identifier).Value;
            Consume(TokenType.Colon);
            string type = ConsumeType();

            Consume(TokenType.Equals, "Variables/Constants must be initialized explicitly.");
            var init = ParseExpression();
            Consume(TokenType.Semicolon);

            return new VariableDeclarationNode(type, name, init, isConst);
        }

        private IfNode ParseIfStatement()
        {
            Consume(TokenType.Keyword_If);
            Consume(TokenType.OpenParen);
            var condition = ParseExpression();
            Consume(TokenType.CloseParen);
            var thenBranch = ParseBlock();

            BlockNode? elseBranch = null;
            if (Match(TokenType.Keyword_Else))
                elseBranch = ParseBlock();

            return new IfNode(condition, thenBranch, elseBranch);
        }

        private WhileNode ParseWhileStatement()
        {
            Consume(TokenType.Keyword_While);
            Consume(TokenType.OpenParen);
            var condition = ParseExpression();
            Consume(TokenType.CloseParen);
            var body = ParseBlock();
            return new WhileNode(condition, body);
        }

        private ForNode ParseForStatement()
        {
            Consume(TokenType.Keyword_For);
            Consume(TokenType.OpenParen);

            AstNode? initializer = null;
            if (Current.Type != TokenType.Semicolon)
            {
                if (Current.Type == TokenType.Keyword_Var)
                    initializer = ParseVariableDeclaration();
                else
                {
                    initializer = ParseExpression();
                    Consume(TokenType.Semicolon);
                }
            }
            else Consume(TokenType.Semicolon);

            AstNode? condition = null;
            if (Current.Type != TokenType.Semicolon)
                condition = ParseExpression();
            Consume(TokenType.Semicolon);

            AstNode? increment = null;
            if (Current.Type != TokenType.CloseParen)
                increment = ParseExpression();
            Consume(TokenType.CloseParen);

            return new ForNode(initializer, condition, increment, ParseBlock());
        }

        private FunctionDeclarationNode ParseFunction(string moduleOwner)
        {
            Consume(TokenType.Keyword_Func);
            string name = Consume(TokenType.Identifier).Value;
            Consume(TokenType.OpenParen);

            var parameters = new List<ParameterNode>();
            if (Current.Type != TokenType.CloseParen)
            {
                do
                {
                    string pName = Consume(TokenType.Identifier).Value;
                    Consume(TokenType.Colon);
                    string pType = ConsumeType();
                    parameters.Add(new ParameterNode(pName, pType));
                } while (Match(TokenType.Comma));
            }
            Consume(TokenType.CloseParen);
            Consume(TokenType.Colon);
            string retType = ConsumeType();

            return new FunctionDeclarationNode(name, retType, parameters, ParseBlock(), moduleOwner);
        }

        private BlockNode ParseBlock()
        {
            Consume(TokenType.OpenBrace);
            var block = new BlockNode();
            while (Current.Type != TokenType.CloseBrace && Current.Type != TokenType.EndOfFile)
                block.Statements.Add(ParseStatement());
            Consume(TokenType.CloseBrace);
            return block;
        }

        private string ConsumeType()
        {
            if (Current.Type >= TokenType.Type_I8 && Current.Type <= TokenType.Type_Void)
            {
                string v = Current.Value;
                _pos++;
                return v;
            }
            throw new CompilerException(Current, "S003", $"Expected Type, found {Current.Type}");
        }

        // --- Expression Parsing Hierarchy (Ordered by Precedence) ---

        private AstNode ParseExpression() => ParseAssignment();

        private AstNode ParseAssignment()
        {
            var expr = ParseLogicalOr();
            if (Match(TokenType.Equals))
            {
                var value = ParseAssignment(); // Right-associative
                if (expr is IdentifierNode id) return new AssignmentNode(id.Name, value);
                throw new CompilerException(Current, "S005", "Invalid assignment target.");
            }
            return expr;
        }

        private AstNode ParseLogicalOr()
        {
            var left = ParseLogicalAnd();
            while (Match(TokenType.PipePipe))
                left = new BinaryExpressionNode(left, TokenType.PipePipe, ParseLogicalAnd());
            return left;
        }

        private AstNode ParseLogicalAnd()
        {
            var left = ParseEquality();
            while (Match(TokenType.AmpersandAmpersand))
                left = new BinaryExpressionNode(left, TokenType.AmpersandAmpersand, ParseEquality());
            return left;
        }

        private AstNode ParseEquality()
        {
            var left = ParseRelational();
            while (Current.Type == TokenType.EqualEqual || Current.Type == TokenType.NotEqual)
            {
                var op = Current.Type; _pos++;
                left = new BinaryExpressionNode(left, op, ParseRelational());
            }
            return left;
        }

        private AstNode ParseRelational()
        {
            var left = ParseAdditive();
            while (Current.Type == TokenType.Less || Current.Type == TokenType.LessEqual ||
                   Current.Type == TokenType.Greater || Current.Type == TokenType.GreaterEqual)
            {
                var op = Current.Type; _pos++;
                left = new BinaryExpressionNode(left, op, ParseAdditive());
            }
            return left;
        }

        private AstNode ParseAdditive()
        {
            var left = ParseMultiplicative();
            while (Current.Type == TokenType.Plus || Current.Type == TokenType.Minus)
            {
                var op = Current.Type; _pos++;
                left = new BinaryExpressionNode(left, op, ParseMultiplicative());
            }
            return left;
        }

        private AstNode ParseMultiplicative()
        {
            var left = ParseUnary();
            while (Current.Type == TokenType.Asterisk || Current.Type == TokenType.Slash || Current.Type == TokenType.Percent)
            {
                var op = Current.Type; _pos++;
                left = new BinaryExpressionNode(left, op, ParseUnary());
            }
            return left;
        }

        private AstNode ParseUnary()
        {
            if (Current.Type == TokenType.Bang || Current.Type == TokenType.Minus)
            {
                var op = Current.Type; _pos++;
                return new UnaryExpressionNode(op, ParseUnary());
            }
            return ParsePostfix();
        }

        private AstNode ParsePostfix()
        {
            var left = ParseCastExpression();
            if (Match(TokenType.PlusPlus))
                return new UnaryExpressionNode(TokenType.PlusPlus, left, isPostfix: true);
            return left;
        }

        private AstNode ParseCastExpression()
        {
            var expr = ParsePrimary();
            while (Match(TokenType.Keyword_As))
                expr = new CastExpressionNode(expr, ConsumeType());
            return expr;
        }

        private AstNode ParsePrimary()
        {
            if (Match(TokenType.Keyword_True)) return new LiteralNode(true, "b8");
            if (Match(TokenType.Keyword_False)) return new LiteralNode(false, "b8");
            if (Current.Type == TokenType.Integer) return new LiteralNode(Consume(TokenType.Integer).Value, "i32");
            if (Current.Type == TokenType.Float) return new LiteralNode(Consume(TokenType.Float).Value, "f64");
            if (Current.Type == TokenType.String) return new LiteralNode(Consume(TokenType.String).Value, "string");

            if (Current.Type == TokenType.Identifier)
            {
                string name = Consume(TokenType.Identifier).Value;
                while (Match(TokenType.DoubleColon)) name += "::" + Consume(TokenType.Identifier).Value;

                if (Match(TokenType.OpenParen))
                {
                    var args = new List<AstNode>();
                    if (Current.Type != TokenType.CloseParen)
                    {
                        do { args.Add(ParseExpression()); } while (Match(TokenType.Comma));
                    }
                    Consume(TokenType.CloseParen);
                    return new FunctionCallNode(name, args);
                }
                return new IdentifierNode(name);
            }

            if (Match(TokenType.OpenParen))
            {
                var expr = ParseExpression();
                Consume(TokenType.CloseParen);
                return expr;
            }

            throw new CompilerException(Current, "S004", $"Unexpected token: {Current.Type}");
        }
    }
}