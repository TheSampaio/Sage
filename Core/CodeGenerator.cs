using Sage.Ast;
using Sage.Interfaces;
using System.Text;

namespace Sage.Core
{
    /// <summary>
    /// Transpiles the AST into standard C11 source code.
    /// </summary>
    public class CodeGenerator : ICodeGenerator, IAstVisitor<string>
    {
        private readonly HashSet<string> _requiredHeaders = [];
        private int _indent = 0;
        private bool _usesTypes = false;

        private string Indent => new(' ', _indent * 4);

        public string Generate(ProgramNode ast)
        {
            _requiredHeaders.Clear();
            _usesTypes = false;

            // Pass 1: Generate body to detect dependencies
            string bodyCode = ast.Accept(this);

            var sb = new StringBuilder();
            sb.AppendLine("/* --- Generated by Sage Compiler --- */");

            // Pass 2: Write Headers
            foreach (var header in _requiredHeaders)
            {
                string include = (header.StartsWith('<') || header.StartsWith('"'))
                    ? header
                    : $"<{header}>";
                sb.AppendLine($"#include {include}");
            }

            // Pass 3: Type Definitions
            if (_usesTypes)
            {
                AppendTypeDefinitions(sb);
            }

            // Pass 4: Module Includes
            var useNodes = ast.Statements.OfType<UseNode>().ToList();
            if (useNodes.Count > 0)
            {
                sb.AppendLine("\n/* --- Module Includes --- */");
                foreach (var stmt in useNodes) sb.Append(stmt.Accept(this));
            }

            sb.AppendLine("\n/* --- Generated Logic --- */");
            sb.Append(bodyCode);

            return sb.ToString();
        }

        private void AppendTypeDefinitions(StringBuilder sb)
        {
            if (!_requiredHeaders.Contains("stdint.h")) sb.AppendLine("#include <stdint.h>");
            if (!_requiredHeaders.Contains("stdbool.h")) sb.AppendLine("#include <stdbool.h>");

            sb.AppendLine("\n/* --- Sage Type Definitions --- */");
            sb.AppendLine("typedef int8_t   i8;  typedef uint8_t  u8;");
            sb.AppendLine("typedef int16_t  i16; typedef uint16_t u16;");
            sb.AppendLine("typedef int32_t  i32; typedef uint32_t u32;");
            sb.AppendLine("typedef int64_t  i64; typedef uint64_t u64;");
            sb.AppendLine("typedef float    f32; typedef double   f64;");
            sb.AppendLine("typedef bool     b8;  typedef char* str;");
            sb.AppendLine("typedef void     none;");
        }

        public string Visit(FunctionDeclarationNode node)
        {
            if (node.IsExtern) return "";

            _usesTypes = true;
            bool isMain = node.Name.Equals("main", StringComparison.OrdinalIgnoreCase);

            string cReturnType = isMain ? "int" : TypeSystem.ToCType(node.ReturnType);
            string cName = ResolveFunctionName(node);

            var sb = new StringBuilder();
            sb.Append($"{Indent}{cReturnType} {cName}(");

            if (node.Parameters.Count == 0) sb.Append("void");
            else
            {
                var paramsList = node.Parameters.Select(p => $"{TypeSystem.ToCType(p.Type)} {p.Name}");
                sb.Append(string.Join(", ", paramsList));
            }
            sb.AppendLine(")");

            // Body Generation
            sb.AppendLine($"{Indent}{{");
            _indent++;

            if (node.Body != null)
                foreach (var stmt in node.Body.Statements) sb.Append(stmt.Accept(this));

            if (isMain) sb.AppendLine($"{Indent}return 0;");

            _indent--;
            sb.AppendLine($"{Indent}}}");

            return sb.ToString();
        }

        private static string ResolveFunctionName(FunctionDeclarationNode node)
        {
            if (node.Name.Equals("main", StringComparison.OrdinalIgnoreCase)) return "main";
            return string.IsNullOrEmpty(node.ModuleOwner) ? node.Name : $"{node.ModuleOwner}_{node.Name}";
        }

        public string Visit(FunctionCallNode node)
        {
            // Standard Library Detection
            if (node.Name.Contains("printf")) _requiredHeaders.Add("stdio.h");
            if (node.Name.Contains("malloc") || node.Name.Contains("free") || node.Name.Contains("system"))
                _requiredHeaders.Add("stdlib.h");

            string cName = node.Name;

            // Handle Namespaces
            if (cName.Contains("::"))
            {
                // Extern calls (FFI) strip the alias, internal calls use underscore mangling
                cName = node.IsExternCall
                    ? cName.Split("::")[1]
                    : cName.Replace("::", "_");
            }

            var cArgs = node.Arguments.Select(a => a.Accept(this));
            return $"{cName}({string.Join(", ", cArgs)})";
        }

        public string Visit(VariableDeclarationNode node)
        {
            _usesTypes = true;
            string prefix = node.IsConstant ? "const " : "";
            return $"{Indent}{prefix}{TypeSystem.ToCType(node.Type)} {node.Name} = {node.Initializer.Accept(this)};\n";
        }

        public string Visit(LiteralNode node)
        {
            if (node.TypeName == "string")
            {
                _usesTypes = true;
                return $"\"{node.Value}\"";
            }
            if (node.TypeName == "b8")
            {
                _usesTypes = true;
                return (bool)node.Value ? "true" : "false";
            }
            if (node.TypeName == "f32")
            {
                string val = node.Value.ToString()!.Replace(",", ".");
                return val.Contains('.') ? $"{val}f" : $"{val}.0f";
            }
            return node.Value.ToString()!.Replace(",", ".");
        }

        // --- Standard Visitor Implementations ---
        public string Visit(ProgramNode node)
        {
            var sb = new StringBuilder();
            foreach (var stmt in node.Statements)
                if (stmt is not UseNode) sb.Append(stmt.Accept(this));
            return sb.ToString();
        }

        public string Visit(ModuleNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"\n/* Module: {node.Name} */");
            foreach (var member in node.Members)
            {
                if (member is FunctionDeclarationNode func) func.ModuleOwner = node.Name;
                sb.Append(member.Accept(this));
            }
            return sb.ToString();
        }

        public string Visit(BlockNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}{{");
            _indent++;
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            _indent--;
            sb.AppendLine($"{Indent}}}");
            return sb.ToString();
        }

        public string Visit(AssignmentNode node) => $"{Indent}{node.Name} = {node.Expression.Accept(this)};\n";
        public string Visit(IdentifierNode node) => node.Name.Replace("::", "_");
        public string Visit(ReturnNode node) => $"{Indent}return {node.Expression.Accept(this)};\n";
        public string Visit(ExpressionStatementNode node) => $"{Indent}{node.Expression.Accept(this)};\n";
        public string Visit(UseNode node) => $"#include \"{node.Module}.h\"\n";
        public string Visit(BinaryExpressionNode node) => $"({node.Left.Accept(this)} + {node.Right.Accept(this)})";
        public string Visit(CastExpressionNode node) => $"(({TypeSystem.ToCType(node.TargetType)}){node.Expression.Accept(this)})";
        public string Visit(ExternBlockNode node) { _requiredHeaders.Add(node.Header); return ""; }

        // Future/Unimplemented
        public string Visit(IfNode node) => "";
        public string Visit(WhileNode node) => "";
        public string Visit(ForNode node) => "";
        public string Visit(UnaryExpressionNode node) => "";
        public string Visit(InterpolatedStringNode node) => "";
    }
}