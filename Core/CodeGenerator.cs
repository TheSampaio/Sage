using Sage.Ast;
using Sage.Enums;
using Sage.Interfaces;
using System.Text;

namespace Sage.Core
{
    /// <summary>
    /// Responsible for traversing the Sage AST and emitting equivalent C code.
    /// Implements the Visitor pattern to decouple node logic from code emission.
    /// </summary>
    public class CodeGenerator : ICodeGenerator, IAstVisitor<string>
    {
        private int _indent = 0;
        private string Indent => new(' ', _indent * 4);

        /// <summary>
        /// Entry point for the code generation. Prepends standard headers and Sage type aliases.
        /// </summary>
        /// <param name="ast">The root program node.</param>
        /// <returns>A string containing the full C source code.</returns>
        public string Generate(ProgramNode ast)
        {
            var sb = new StringBuilder();
            sb.AppendLine("/* --- Generated by Sage Compiler --- */");
            sb.AppendLine("#include <stdio.h>");
            sb.AppendLine("#include <stdint.h>");
            sb.AppendLine("#include <stdbool.h>");
            sb.AppendLine("#include <uchar.h>");
            sb.AppendLine("");

            sb.AppendLine("/* --- Sage Type Definitions --- */");

            sb.AppendLine("typedef int8_t i8;");
            sb.AppendLine("typedef int16_t i16;");
            sb.AppendLine("typedef int32_t i32;");
            sb.AppendLine("typedef int64_t i64;");

            sb.AppendLine("typedef uint8_t u8;");
            sb.AppendLine("typedef uint16_t u16;");
            sb.AppendLine("typedef uint32_t u32;");
            sb.AppendLine("typedef uint64_t u64;");

            sb.AppendLine("typedef float f32;");
            sb.AppendLine("typedef double f64;");

            sb.AppendLine("typedef bool b8;");
            sb.AppendLine("typedef char c8;");
            sb.AppendLine("typedef char16_t c16;");
            sb.AppendLine("typedef char32_t c32;");

            sb.AppendLine("typedef char* str;");
            sb.AppendLine("typedef void none;");

            sb.AppendLine("");
            sb.AppendLine("/* --- Generated Logic --- */");

            sb.Append(ast.Accept(this));
            return sb.ToString();
        }

        public string Visit(ProgramNode node)
        {
            var sb = new StringBuilder();
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            return sb.ToString();
        }

        /// <summary>
        /// Handles module-level scoping by prefixing functions with the module name.
        /// </summary>
        public string Visit(ModuleNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"// Module: {node.Name}");
            foreach (var func in node.Functions)
            {
                func.ModuleOwner = node.Name;
                sb.Append(func.Accept(this));
            }
            return sb.ToString();
        }

        /// <summary>
        /// Translates Sage function declarations to C, ensuring 'main' follows standard C naming.
        /// </summary>
        public string Visit(FunctionDeclarationNode node)
        {
            var sb = new StringBuilder();
            string cName = node.Name;

            if (!string.IsNullOrEmpty(node.ModuleOwner))
                cName = $"{node.ModuleOwner}_{node.Name}";

            if (node.Name.Equals("main", StringComparison.CurrentCultureIgnoreCase))
                cName = "main";

            sb.Append($"{Indent}{node.ReturnType} {cName}(");

            for (int i = 0; i < node.Parameters.Count; i++)
            {
                sb.Append($"{node.Parameters[i].Type} {node.Parameters[i].Name}");
                if (i < node.Parameters.Count - 1) sb.Append(", ");
            }

            sb.AppendLine(")");
            sb.Append(node.Body.Accept(this));
            return sb.ToString();
        }

        public string Visit(BlockNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}{{");
            _indent++;
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            _indent--;
            sb.AppendLine($"{Indent}}}");
            return sb.ToString();
        }

        public string Visit(VariableDeclarationNode node)
        {
            return $"{Indent}{node.Type} {node.Name} = {node.Initializer.Accept(this)};\n";
        }

        public string Visit(ReturnNode node)
        {
            return $"{Indent}return {node.Expression.Accept(this)};\n";
        }

        public string Visit(ExpressionStatementNode node)
        {
            return $"{Indent}{node.Expression.Accept(this)};\n";
        }

        public string Visit(UseNode node)
        {
            return $"// use {node.Module};\n";
        }

        public string Visit(BinaryExpressionNode node)
        {
            string op = node.Operator switch
            {
                TokenType.Plus => "+",
                TokenType.Minus => "-",
                TokenType.Asterisk => "*",
                TokenType.Slash => "/",
                _ => "?"
            };
            return $"({node.Left.Accept(this)} {op} {node.Right.Accept(this)})";
        }

        public string Visit(LiteralNode node)
        {
            if (node.TypeName == "string") return $"\"{node.Value}\"";

            if (node.TypeName == "f32") return $"{node.Value}f";

            return node.Value.ToString();
        }

        public string Visit(IdentifierNode node)
        {
            return node.Name.Replace("::", "_");
        }

        /// <summary>
        /// Translates function calls. Implements a specialized transformation for 'console::print_line' 
        /// into C's 'printf' with basic interpolation support.
        /// </summary>
        public string Visit(FunctionCallNode node)
        {
            if (node.Name == "console::print_line")
            {
                var sb = new StringBuilder();
                sb.Append("printf(");

                if (node.Arguments.Count > 0 && node.Arguments[0] is LiteralNode lit)
                {
                    string template = lit.Value.ToString();
                    var vars = new List<string>();
                    var cleanTemplate = new StringBuilder();
                    bool inside = false;
                    var currentVar = new StringBuilder();

                    foreach (char c in template)
                    {
                        if (c == '{') { inside = true; cleanTemplate.Append("%d"); continue; }
                        if (c == '}')
                        {
                            inside = false;
                            string rawVar = currentVar.ToString();
                            vars.Add(rawVar.Replace("::", "_"));
                            currentVar.Clear();
                            continue;
                        }
                        if (inside) currentVar.Append(c);
                        else cleanTemplate.Append(c);
                    }

                    cleanTemplate.Append("\\n");
                    sb.Append($"\"{cleanTemplate}\"");

                    if (vars.Count > 0) sb.Append(", ");
                    sb.Append(string.Join(", ", vars));
                }
                sb.Append(')');
                return sb.ToString();
            }

            string cName = node.Name.Replace("::", "_");
            var args = node.Arguments.Select(a => a.Accept(this));
            return $"{cName}({string.Join(", ", args)})";
        }

        public string Visit(InterpolatedStringNode node) => "\"Not Implemented\"";
    }
}