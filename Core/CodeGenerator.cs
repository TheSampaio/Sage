using System.Text;
using Sage.Ast;
using Sage.Enums;
using Sage.Interfaces;

namespace Sage.Core
{
    public class CodeGenerator : ICodeGenerator, IAstVisitor<string>
    {
        private int _indent = 0;
        private string Indent => new(' ', _indent * 4);

        public string Generate(ProgramNode ast)
        {
            var sb = new StringBuilder();
            sb.AppendLine("/* --- Generated by Sage Compiler --- */");
            sb.AppendLine("#include <stdio.h>");
            sb.AppendLine("#include <stdint.h>");
            sb.AppendLine("#include <stdbool.h>");
            sb.AppendLine("#include <uchar.h>");
            sb.AppendLine("");

            sb.AppendLine("/* --- Sage Type Definitions --- */");
            sb.AppendLine("typedef int8_t   i8;  typedef uint8_t  u8;");
            sb.AppendLine("typedef int16_t  i16; typedef uint16_t u16;");
            sb.AppendLine("typedef int32_t  i32; typedef uint32_t u32;");
            sb.AppendLine("typedef int64_t  i64; typedef uint64_t u64;");
            sb.AppendLine("typedef float    f32; typedef double   f64;");
            sb.AppendLine("typedef bool     b8;  typedef char* str;");
            sb.AppendLine("typedef void     none;");
            sb.AppendLine("");

            sb.AppendLine("/* --- Generated Logic --- */");
            sb.Append(ast.Accept(this));

            return sb.ToString();
        }

        public string Visit(ProgramNode node)
        {
            var sb = new StringBuilder();
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            return sb.ToString();
        }

        public string Visit(ModuleNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"/* Module: {node.Name} */");
            foreach (var func in node.Functions)
            {
                func.ModuleOwner = node.Name;
                sb.Append(func.Accept(this));
            }
            return sb.ToString();
        }

        public string Visit(FunctionDeclarationNode node)
        {
            bool isMain = node.Name.Equals("main", StringComparison.OrdinalIgnoreCase);
            string cReturnType = isMain ? "int" : ConvertType(node.ReturnType);
            string cName = isMain ? "main" : (string.IsNullOrEmpty(node.ModuleOwner) ? node.Name : $"{node.ModuleOwner}_{node.Name}");

            var sb = new StringBuilder();
            sb.Append($"{Indent}{cReturnType} {cName}(");

            if (node.Parameters.Count == 0)
            {
                sb.Append("void");
            }
            else
            {
                for (int i = 0; i < node.Parameters.Count; i++)
                {
                    sb.Append($"{ConvertType(node.Parameters[i].Type)} {node.Parameters[i].Name}");
                    if (i < node.Parameters.Count - 1) sb.Append(", ");
                }
            }
            sb.AppendLine(")");

            if (isMain)
            {
                sb.AppendLine($"{Indent}{{");
                _indent++;
                foreach (var stmt in node.Body.Statements) sb.Append(stmt.Accept(this));
                sb.AppendLine($"{Indent}return 0;");
                _indent--;
                sb.AppendLine($"{Indent}}}");
            }
            else
            {
                sb.Append(node.Body.Accept(this));
            }

            return sb.ToString();
        }

        public string Visit(BlockNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}{{");
            _indent++;
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            _indent--;
            sb.AppendLine($"{Indent}}}");
            return sb.ToString();
        }

        public string Visit(VariableDeclarationNode node)
        {
            string prefix = node.IsConstant ? "const " : "";
            // Removed extra indentation call here to prevent drift
            return $"{Indent}{prefix}{ConvertType(node.Type)} {node.Name} = {node.Initializer.Accept(this)};\n";
        }

        // Assignment doesn't need Indent/Semicolon because it's usually inside an ExpressionStatement
        public string Visit(AssignmentNode node) => $"{node.Name} = {node.Expression.Accept(this)}";

        public string Visit(IfNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}if ({node.Condition.Accept(this)})");
            sb.Append(node.ThenBranch.Accept(this));
            if (node.ElseBranch != null)
            {
                sb.AppendLine($"{Indent}else");
                sb.Append(node.ElseBranch.Accept(this));
            }
            return sb.ToString();
        }

        public string Visit(WhileNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}while ({node.Condition.Accept(this)})");
            sb.Append(node.Body.Accept(this));
            return sb.ToString();
        }

        public string Visit(ForNode node)
        {
            var sb = new StringBuilder();
            string init = node.Initializer != null ? node.Initializer.Accept(this).Trim().TrimEnd(';') : "";
            string cond = node.Condition != null ? node.Condition.Accept(this) : "";
            string inc = node.Increment != null ? node.Increment.Accept(this) : "";

            sb.AppendLine($"{Indent}for ({init}; {cond}; {inc})");
            sb.Append(node.Body.Accept(this));
            return sb.ToString();
        }

        public string Visit(BinaryExpressionNode node)
        {
            string op = node.Operator switch
            {
                TokenType.Plus => "+",
                TokenType.Minus => "-",
                TokenType.Asterisk => "*",
                TokenType.Slash => "/",
                TokenType.Percent => "%",
                TokenType.EqualEqual => "==",
                TokenType.NotEqual => "!=",
                TokenType.Less => "<",
                TokenType.LessEqual => "<=",
                TokenType.Greater => ">",
                TokenType.GreaterEqual => ">=",
                TokenType.AmpersandAmpersand => "&&",
                TokenType.PipePipe => "||",
                _ => "?"
            };
            return $"({node.Left.Accept(this)} {op} {node.Right.Accept(this)})";
        }

        public string Visit(UnaryExpressionNode node)
        {
            if (node.IsPostfix && node.Operator == TokenType.PlusPlus)
                return $"({node.Operand.Accept(this)}++)";

            string op = node.Operator switch { TokenType.Bang => "!", TokenType.Minus => "-", _ => "" };
            return $"({op}{node.Operand.Accept(this)})";
        }

        public string Visit(LiteralNode node)
        {
            if (node.TypeName == "string") return $"\"{node.Value}\"";
            if (node.TypeName == "b8") return (bool)node.Value ? "true" : "false";
            return node.Value.ToString() ?? "";
        }

        public string Visit(IdentifierNode node) => node.Name.Replace("::", "_");

        /// <summary>
        /// Fixed: Generates the printf call without internal indentation or semicolons.
        /// </summary>
        public string Visit(FunctionCallNode node)
        {
            if (node.Name == "console::print_line" && node.Arguments[0] is LiteralNode lit)
            {
                string tpl = lit.Value.ToString() ?? "";
                var parts = tpl.Split('{', '}');
                var fmt = new StringBuilder();
                var args = new List<string>();

                for (int i = 0; i < parts.Length; i++)
                {
                    if (i % 2 == 0) fmt.Append(parts[i]);
                    else
                    {
                        fmt.Append("%d");
                        args.Add(parts[i].Replace("::", "_"));
                    }
                }
                string argsStr = args.Count > 0 ? ", " + string.Join(", ", args) : "";
                // Return just the C expression
                return $"printf(\"{fmt}\\n\"{argsStr})";
            }

            var cArgs = node.Arguments.Select(a => a.Accept(this));
            return $"{node.Name.Replace("::", "_")}({string.Join(", ", cArgs)})";
        }

        public string Visit(ReturnNode node) => $"{Indent}return {node.Expression.Accept(this)};\n";

        /// <summary>
        /// This is the primary driver for expression formatting in the C file.
        /// It provides the indentation and the terminal semicolon.
        /// </summary>
        public string Visit(ExpressionStatementNode node) => $"{Indent}{node.Expression.Accept(this)};\n";

        public string Visit(UseNode node) => "";
        public string Visit(InterpolatedStringNode node) => "";
        public string Visit(CastExpressionNode node) => $"(({ConvertType(node.TargetType)}){node.Expression.Accept(this)})";

        private string ConvertType(string t) => t == "void" ? "none" : t;
    }
}