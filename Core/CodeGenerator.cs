using Sage.Ast;
using Sage.Interfaces;
using System.Text;

namespace Sage.Core
{
    /// <summary>
    /// The primary backend of the Sage compiler. 
    /// It traverses the validated Abstract Syntax Tree (AST) using the Visitor pattern 
    /// and transpiles it into standard C source code.
    /// </summary>
    public class CodeGenerator : ICodeGenerator, IAstVisitor<string>
    {
        private int _indent = 0;
        private string Indent => new(' ', _indent * 4);

        /// <summary>Flag triggered when <c>printf</c> or <c>system</c> calls are detected.</summary>
        private bool _usesStdIo = false;

        /// <summary>Flag triggered when Sage-specific types or typedefs are required.</summary>
        private bool _usesTypes = false;

        /// <summary>
        /// Translates the entire program starting from the root node.
        /// Performs a two-pass generation: first collecting metadata (like required headers) 
        /// and then assembling the final source string.
        /// </summary>
        /// <param name="ast">The root node of the program.</param>
        /// <returns>A string containing the generated C source code.</returns>
        public string Generate(ProgramNode ast)
        {
            _usesStdIo = false;
            _usesTypes = false;

            // 1. Generate body first to populate header flags
            string bodyCode = ast.Accept(this);

            var sb = new StringBuilder();
            sb.AppendLine("/* --- Generated by Sage Compiler --- */");

            // 2. Dynamic Header Includes
            if (_usesStdIo)
            {
                sb.AppendLine("#include <stdio.h>");
                sb.AppendLine("#include <stdlib.h>"); // Required for system()
            }

            if (_usesTypes)
            {
                sb.AppendLine("#include <stdint.h>");
                sb.AppendLine("#include <stdbool.h>");
                sb.AppendLine("#include <uchar.h>");
                sb.AppendLine("");
                sb.AppendLine("/* --- Sage Type Definitions --- */");
                sb.AppendLine("typedef int8_t   i8;  typedef uint8_t  u8;");
                sb.AppendLine("typedef int16_t  i16; typedef uint16_t u16;");
                sb.AppendLine("typedef int32_t  i32; typedef uint32_t u32;");
                sb.AppendLine("typedef int64_t  i64; typedef uint64_t u64;");
                sb.AppendLine("typedef float    f32; typedef double   f64;");
                sb.AppendLine("typedef bool     b8;  typedef char* str;");
                sb.AppendLine("typedef void     none;");
            }

            // 3. Module Includes (Links to generated .h files)
            var useNodes = ast.Statements.OfType<UseNode>().ToList();
            if (useNodes.Count > 0)
            {
                sb.AppendLine("");
                sb.AppendLine("/* --- Module Includes --- */");
                foreach (var stmt in useNodes) sb.Append(stmt.Accept(this));
            }

            sb.AppendLine("");
            sb.AppendLine("/* --- Generated Logic --- */");
            sb.Append(bodyCode);

            return sb.ToString();
        }

        /// <summary>
        /// Maps Sage types to their C equivalents and triggers type definition headers.
        /// </summary>
        private string ConvertType(string sageType)
        {
            _usesTypes = true;
            return sageType switch
            {
                "none" => "none",
                "str" => "str",
                "i32" => "i32",
                "f32" => "f32",
                "b8" => "b8",
                _ => sageType
            };
        }

        /// <summary>Generates a C function definition.</summary>
        public string Visit(FunctionDeclarationNode node)
        {
            if (node.IsExtern) return ""; // Externs only appear in headers

            _usesTypes = true;
            bool isMain = node.Name.Equals("main", StringComparison.OrdinalIgnoreCase);
            string cReturnType = isMain ? "int" : ConvertType(node.ReturnType);

            // Resolve Name: handles entry point naming vs module-namespaced functions
            string cName = isMain
                ? "main"
                : (string.IsNullOrEmpty(node.ModuleOwner) ? node.Name : $"{node.ModuleOwner}_{node.Name}");

            var sb = new StringBuilder();
            sb.Append($"{Indent}{cReturnType} {cName}(");

            if (node.Parameters.Count == 0) sb.Append("void");
            else
            {
                var paramsList = node.Parameters.Select(p => $"{ConvertType(p.Type)} {p.Name}");
                sb.Append(string.Join(", ", paramsList));
            }
            sb.AppendLine(")");

            if (isMain)
            {
                sb.AppendLine($"{Indent}{{");
                _indent++;
                if (node.Body != null) foreach (var stmt in node.Body.Statements) sb.Append(stmt.Accept(this));
                sb.AppendLine($"{Indent}return 0;");
                _indent--;
                sb.AppendLine($"{Indent}}}");
            }
            else
            {
                sb.Append(node.Body.Accept(this));
            }

            return sb.ToString();
        }

        /// <summary>Generates a function call and tracks standard library usage.</summary>
        public string Visit(FunctionCallNode node)
        {
            if (node.Name.Contains("printf") || node.Name.Contains("system")) _usesStdIo = true;

            var cArgs = node.Arguments.Select(a => a.Accept(this));
            string cName = node.Name.Replace("::", "_");

            // Special override for raw C interop calls
            if (node.Name == "printf" || node.Name == "system") cName = node.Name;

            return $"{cName}({string.Join(", ", cArgs)})";
        }

        /// <summary>Converts literal values into C-compliant constants.</summary>
        public string Visit(LiteralNode node)
        {
            if (node.TypeName == "string")
            {
                _usesTypes = true;
                return $"\"{node.Value}\"";
            }

            if (node.TypeName == "b8")
            {
                _usesTypes = true;
                return (bool)node.Value ? "true" : "false";
            }

            if (node.TypeName == "f32")
            {
                string val = node.Value.ToString()!.Replace(",", ".");
                return val.Contains('.') ? $"{val}f" : $"{val}.0f";
            }

            return node.Value.ToString()!.Replace(",", ".");
        }

        /// <summary>Visits the root program node.</summary>
        public string Visit(ProgramNode node)
        {
            var sb = new StringBuilder();
            foreach (var stmt in node.Statements)
                if (stmt is not UseNode) sb.Append(stmt.Accept(this));
            return sb.ToString();
        }

        /// <summary>Visits a module node to generate its internal functions.</summary>
        public string Visit(ModuleNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"\n/* Module: {node.Name} */");
            foreach (var func in node.Functions)
            {
                func.ModuleOwner = node.Name;
                sb.Append(func.Accept(this));
            }
            return sb.ToString();
        }

        /// <summary>Generates a C code block with proper indentation.</summary>
        public string Visit(BlockNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}{{");
            _indent++;
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            _indent--;
            sb.AppendLine($"{Indent}}}");
            return sb.ToString();
        }

        /// <summary>Generates a variable or constant declaration.</summary>
        public string Visit(VariableDeclarationNode node)
        {
            _usesTypes = true;
            string prefix = node.IsConstant ? "const " : "";
            return $"{Indent}{prefix}{ConvertType(node.Type)} {node.Name} = {node.Initializer.Accept(this)};\n";
        }

        /// <summary>Generates a standard assignment statement.</summary>
        public string Visit(AssignmentNode node) => $"{Indent}{node.Name} = {node.Expression.Accept(this)};\n";

        /// <summary>Generates an identifier reference, converting namespaces to C underscores.</summary>
        public string Visit(IdentifierNode node) => node.Name.Replace("::", "_");

        /// <summary>Generates a return statement.</summary>
        public string Visit(ReturnNode node) => $"{Indent}return {node.Expression.Accept(this)};\n";

        /// <summary>Generates a statement consisting of a single expression.</summary>
        public string Visit(ExpressionStatementNode node) => $"{Indent}{node.Expression.Accept(this)};\n";

        /// <summary>Generates a C include for imported modules.</summary>
        public string Visit(UseNode node) => $"#include \"{node.Module}.h\"\n";

        /// <summary>Generates a binary expression (Current placeholder logic: Addition).</summary>
        public string Visit(BinaryExpressionNode node) => $"({node.Left.Accept(this)} + {node.Right.Accept(this)})";

        /// <summary>Generates an explicit type cast.</summary>
        public string Visit(CastExpressionNode node) => $"(({ConvertType(node.TargetType)}){node.Expression.Accept(this)})";

        public string Visit(IfNode node) => "";
        public string Visit(WhileNode node) => "";
        public string Visit(ForNode node) => "";
        public string Visit(UnaryExpressionNode node) => "";
        public string Visit(InterpolatedStringNode node) => "";
    }
}