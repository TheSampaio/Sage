using Sage.Ast;
using Sage.Enums;
using Sage.Interfaces;
using System.Text;

namespace Sage.Core
{
    /// <summary>
    /// Transpiles the AST into standard C11 source code.
    /// </summary>
    public class CodeGenerator : ICodeGenerator, IAstVisitor<string>
    {
        private readonly HashSet<string> _requiredHeaders = [];
        private int _indent = 0;
        private bool _usesTypes = false;

        private string Indent => new(' ', _indent * 4);

        public string Generate(ProgramNode ast)
        {
            _requiredHeaders.Clear();
            _usesTypes = false;

            // Pass 1: Generate body to detect dependencies
            string bodyCode = ast.Accept(this);

            var sb = new StringBuilder();
            sb.AppendLine("/* --- Generated by Sage Compiler --- */");

            // Pass 2: Write Headers
            foreach (var header in _requiredHeaders)
            {
                string include = (header.StartsWith('<') || header.StartsWith('"'))
                    ? header
                    : $"<{header}>";
                sb.AppendLine($"#include {include}");
            }

            // Pass 3: Type Definitions
            if (_usesTypes)
            {
                AppendTypeDefinitions(sb);
            }

            // Pass 4: Module Includes
            var useNodes = ast.Statements.OfType<UseNode>().ToList();
            if (useNodes.Count > 0)
            {
                sb.AppendLine("\n/* --- Module Includes --- */");
                foreach (var stmt in useNodes) sb.Append(stmt.Accept(this));
            }

            sb.AppendLine("\n/* --- Generated Logic --- */");
            sb.Append(bodyCode);

            return sb.ToString();
        }

        private void AppendTypeDefinitions(StringBuilder sb)
        {
            if (!_requiredHeaders.Contains("stdint.h")) sb.AppendLine("#include <stdint.h>");
            if (!_requiredHeaders.Contains("stdbool.h")) sb.AppendLine("#include <stdbool.h>");

            sb.AppendLine("\n/* --- Sage Type Definitions --- */");
            sb.AppendLine("typedef int8_t   i8;  typedef uint8_t  u8;");
            sb.AppendLine("typedef int16_t  i16; typedef uint16_t u16;");
            sb.AppendLine("typedef int32_t  i32; typedef uint32_t u32;");
            sb.AppendLine("typedef int64_t  i64; typedef uint64_t u64;");
            sb.AppendLine("typedef float    f32; typedef double   f64;");
            sb.AppendLine("typedef bool     b8;  typedef char* str;");
            sb.AppendLine("typedef void     none;");
        }

        public string Visit(FunctionDeclarationNode node)
        {
            if (node.IsExtern) return "";

            _usesTypes = true;
            bool isMain = node.Name.Equals("main", StringComparison.OrdinalIgnoreCase);

            string cReturnType = isMain ? "int" : TypeSystem.ToCType(node.ReturnType);
            string cName = ResolveFunctionName(node);

            var sb = new StringBuilder();
            sb.Append($"{Indent}{cReturnType} {cName}(");

            if (node.Parameters.Count == 0) sb.Append("void");
            else
            {
                var paramsList = node.Parameters.Select(p => $"{TypeSystem.ToCType(p.Type)} {p.Name}");
                sb.Append(string.Join(", ", paramsList));
            }
            sb.AppendLine(")");

            // Body Generation
            sb.AppendLine($"{Indent}{{");
            _indent++;

            if (node.Body != null)
                foreach (var stmt in node.Body.Statements) sb.Append(stmt.Accept(this));

            if (isMain) sb.AppendLine($"{Indent}return 0;");

            _indent--;
            sb.AppendLine($"{Indent}}}");

            return sb.ToString();
        }

        private static string ResolveFunctionName(FunctionDeclarationNode node)
        {
            if (node.Name.Equals("main", StringComparison.OrdinalIgnoreCase)) return "main";
            return string.IsNullOrEmpty(node.ModuleOwner) ? node.Name : $"{node.ModuleOwner}_{node.Name}";
        }

        public string Visit(FunctionCallNode node)
        {
            // Standard Library Detection
            if (node.Name.Contains("printf")) _requiredHeaders.Add("stdio.h");
            if (node.Name.Contains("malloc") || node.Name.Contains("free") || node.Name.Contains("system"))
                _requiredHeaders.Add("stdlib.h");

            string cName = node.Name;

            // Handle Namespaces
            if (cName.Contains("::"))
            {
                // Extern calls (FFI) strip the alias, internal calls use underscore mangling
                cName = node.IsExternCall
                    ? cName.Split("::")[1]
                    : cName.Replace("::", "_");
            }

            var cArgs = node.Arguments.Select(a => a.Accept(this));
            return $"{cName}({string.Join(", ", cArgs)})";
        }

        public string Visit(VariableDeclarationNode node)
        {
            _usesTypes = true;
            string prefix = node.IsConstant ? "const " : "";
            string init = node.Initializer != null ? $" = {node.Initializer.Accept(this)}" : "";
            return $"{Indent}{prefix}{TypeSystem.ToCType(node.Type)} {node.Name}{init};\n";
        }

        public string Visit(LiteralNode node)
        {
            if (node.TypeName == "str")
            {
                _usesTypes = true;
                return $"\"{node.Value}\"";
            }
            if (node.TypeName == "b8")
            {
                _usesTypes = true;
                return (bool)node.Value ? "true" : "false";
            }
            if (node.TypeName == "f32")
            {
                string val = node.Value.ToString()!.Replace(",", ".");
                return val.Contains('.') ? $"{val}f" : $"{val}.0f";
            }
            return node.Value.ToString()!.Replace(",", ".");
        }

        // --- Standard Visitor Implementations ---
        public string Visit(ProgramNode node)
        {
            var sb = new StringBuilder();
            foreach (var stmt in node.Statements)
                if (stmt is not UseNode) sb.Append(stmt.Accept(this));
            return sb.ToString();
        }

        public string Visit(ModuleNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"\n/* Module: {node.Name} */");
            foreach (var member in node.Members)
            {
                if (member is FunctionDeclarationNode func) func.ModuleOwner = node.Name;
                sb.Append(member.Accept(this));
            }
            return sb.ToString();
        }

        public string Visit(BlockNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}{{");
            _indent++;
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            _indent--;
            sb.AppendLine($"{Indent}}}");
            return sb.ToString();
        }

        public string Visit(AssignmentNode node) => $"{Indent}{node.Name} = {node.Expression.Accept(this)};\n";
        public string Visit(IdentifierNode node) => node.Name.Replace("::", "_");
        public string Visit(ReturnNode node) => $"{Indent}return {node.Expression.Accept(this)};\n";
        public string Visit(ExpressionStatementNode node) => $"{Indent}{node.Expression.Accept(this)};\n";
        public string Visit(UseNode node) => $"#include \"{node.Module}.h\"\n";

        public string Visit(BinaryExpressionNode node)
        {
            string op = node.Operator switch
            {
                TokenType.Plus => "+",
                TokenType.Minus => "-",
                TokenType.Asterisk => "*",
                TokenType.Slash => "/",
                TokenType.Percent => "%",
                TokenType.EqualEqual => "==",
                TokenType.NotEqual => "!=",
                TokenType.Less => "<",
                TokenType.LessEqual => "<=",
                TokenType.Greater => ">",
                TokenType.GreaterEqual => ">=",
                TokenType.AmpersandAmpersand => "&&",
                TokenType.PipePipe => "||",
                _ => "+"
            };

            return $"({node.Left.Accept(this)} {op} {node.Right.Accept(this)})";
        }

        public string Visit(CastExpressionNode node) => $"(({TypeSystem.ToCType(node.TargetType)}){node.Expression.Accept(this)})";
        public string Visit(ExternBlockNode node) { _requiredHeaders.Add(node.Header); return ""; }

        public string Visit(IfNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}if ({node.Condition.Accept(this)})");
            sb.Append(node.ThenBranch.Accept(this));

            if (node.ElseBranch != null)
            {
                if (node.ElseBranch is IfNode)
                {
                    sb.Append($"{Indent}else ");
                    sb.Append(node.ElseBranch.Accept(this).TrimStart());
                }
                else
                {
                    sb.AppendLine($"{Indent}else");
                    sb.Append(node.ElseBranch.Accept(this));
                }
            }

            return sb.ToString();
        }

        public string Visit(WhileNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}while ({node.Condition.Accept(this)})");
            sb.Append(node.Body.Accept(this));
            return sb.ToString();
        }

        public string Visit(ForNode node)
        {
            var sb = new StringBuilder();

            // Trim semi-colons and newlines to prevent double-printing inside the 'for' signature
            string init = node.Initializer != null ? node.Initializer.Accept(this).Trim().TrimEnd(';') : "";
            string cond = node.Condition != null ? node.Condition.Accept(this) : "";
            string inc = node.Increment != null ? node.Increment.Accept(this).Trim().TrimEnd(';') : "";

            sb.AppendLine($"{Indent}for ({init}; {cond}; {inc})");
            sb.Append(node.Body.Accept(this));
            return sb.ToString();
        }

        public string Visit(UnaryExpressionNode node)
        {
            string op = node.Operator switch
            {
                TokenType.PlusPlus => "++",
                TokenType.Minus => "-",
                TokenType.Bang => "!",
                _ => ""
            };

            return node.IsPostfix
                ? $"{node.Operand.Accept(this)}{op}"
                : $"{op}{node.Operand.Accept(this)}";
        }

        public string Visit(InterpolatedStringNode node)
        {
            _requiredHeaders.Add("stdio.h");

            var formatString = new StringBuilder();
            var arguments = new List<string>();

            foreach (var part in node.Parts)
            {
                if (part is LiteralNode lit && lit.TypeName == "str")
                {
                    string safeLiteral = lit.Value.ToString()!.Replace("%", "%%");
                    formatString.Append(safeLiteral);
                }
                else
                {
                    string specifier;

                    if (!string.IsNullOrEmpty(part.FormatSpecifier))
                    {
                        if (TypeSystem.IsFloatingPoint(part.VariableType!))
                        {
                            if (part.FormatSpecifier.StartsWith('.'))
                                specifier = $"%{part.FormatSpecifier}";
                            else if (part.FormatSpecifier.EndsWith('f'))
                                specifier = $"%.{part.FormatSpecifier}";
                            else
                                specifier = $"%{part.FormatSpecifier}";
                        }
                        else
                        {
                            specifier = $"%{part.FormatSpecifier}";
                        }
                    }
                    else
                    {
                        specifier = part.VariableType switch
                        {
                            "i32" or "i16" or "i8" => "%d",
                            "u32" or "u16" or "u8" => "%u",
                            "i64" => "%lld",
                            "u64" => "%llu",
                            "f32" or "f64" => "%f",
                            "str" => "%s",
                            _ => "%d"
                        };
                    }

                    formatString.Append(specifier);
                    arguments.Add(part.Accept(this));
                }
            }

            string argsC = arguments.Count > 0 ? ", " + string.Join(", ", arguments) : "";

            return $"({{ static char _buf[512]; snprintf(_buf, sizeof(_buf), \"{formatString}\"{argsC}); _buf; }})";
        }

        public string Visit(StructDeclarationNode node)
        {
            _usesTypes = true;
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}typedef struct {node.Name} {{");
            _indent++;
            foreach (var field in node.Fields)
            {
                sb.AppendLine($"{Indent}{TypeSystem.ToCType(field.Type)} {field.Name};");
            }
            _indent--;
            sb.AppendLine($"{Indent}}} {node.Name};\n");
            return sb.ToString();
        }

        public string Visit(StructInitializationNode node)
        {
            _usesTypes = true;
            var sb = new StringBuilder();
            sb.Append("{ ");

            var initList = new List<string>();
            foreach (var kvp in node.Fields)
            {
                initList.Add($".{kvp.Key} = {kvp.Value.Accept(this)}");
            }

            sb.Append(string.Join(", ", initList));
            sb.Append(" }");

            return sb.ToString();
        }

        public string Visit(MemberAccessNode node) => $"{node.Object.Accept(this)}.{node.PropertyName}";
    }
}