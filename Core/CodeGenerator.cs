using System.Text;
using Sage.Ast;
using Sage.Enums;
using Sage.Interfaces;

namespace Sage.Core
{
    public class CodeGenerator : ICodeGenerator, IAstVisitor<string>
    {
        private int _indent = 0;
        private string Indent => new(' ', _indent * 4);

        private bool _usesStdIo = false;   // Triggers <stdio.h>
        private bool _usesTypes = false;   // Triggers typedefs

        public string Generate(ProgramNode ast)
        {
            _usesStdIo = false;
            _usesTypes = false;

            // 1. Gera o corpo primeiro para preencher as flags
            string bodyCode = ast.Accept(this);

            var sb = new StringBuilder();
            sb.AppendLine("/* --- Generated by Sage Compiler --- */");

            // 2. Includes dinâmicos
            if (_usesStdIo)
            {
                sb.AppendLine("#include <stdio.h>");
                sb.AppendLine("#include <stdlib.h>"); // Para a função system()
            }

            if (_usesTypes)
            {
                sb.AppendLine("#include <stdint.h>");
                sb.AppendLine("#include <stdbool.h>");
                sb.AppendLine("#include <uchar.h>");
                sb.AppendLine("");
                sb.AppendLine("/* --- Sage Type Definitions --- */");
                sb.AppendLine("typedef int8_t   i8;  typedef uint8_t  u8;");
                sb.AppendLine("typedef int16_t  i16; typedef uint16_t u16;");
                sb.AppendLine("typedef int32_t  i32; typedef uint32_t u32;");
                sb.AppendLine("typedef int64_t  i64; typedef uint64_t u64;");
                sb.AppendLine("typedef float    f32; typedef double   f64;");
                sb.AppendLine("typedef bool     b8;  typedef char* str;");
                sb.AppendLine("typedef void     none;");
            }

            // 3. Includes de Módulos (Headers gerados)
            var useNodes = ast.Statements.OfType<UseNode>().ToList();
            if (useNodes.Count > 0)
            {
                sb.AppendLine("");
                sb.AppendLine("/* --- Module Includes --- */");
                foreach (var stmt in useNodes) sb.Append(stmt.Accept(this));
            }

            sb.AppendLine("");
            sb.AppendLine("/* --- Generated Logic --- */");
            sb.Append(bodyCode);

            return sb.ToString();
        }

        private string ConvertType(string sageType)
        {
            // Ativa a flag de tipos se não for um tipo primitivo puro do C
            _usesTypes = true;

            return sageType switch
            {
                "none" => "none", // Usamos o typedef definido no topo
                "str" => "str",
                "i32" => "i32",
                "f32" => "f32",
                "b8" => "b8",
                _ => sageType
            };
        }

        public string Visit(FunctionDeclarationNode node)
        {
            // IMPORTANTE: Extern não gera corpo no .c
            if (node.IsExtern) return "";

            // Ativa tipos para retorno e parâmetros
            _usesTypes = true;

            bool isMain = node.Name.Equals("main", StringComparison.OrdinalIgnoreCase);
            string cReturnType = isMain ? "int" : ConvertType(node.ReturnType);

            // Resolve nome: main ou modulo_funcao
            string cName = isMain ? "main" : (string.IsNullOrEmpty(node.ModuleOwner) ? node.Name : $"{node.ModuleOwner}_{node.Name}");

            var sb = new StringBuilder();
            sb.Append($"{Indent}{cReturnType} {cName}(");

            if (node.Parameters.Count == 0) sb.Append("void");
            else
            {
                var paramsList = node.Parameters.Select(p => $"{ConvertType(p.Type)} {p.Name}");
                sb.Append(string.Join(", ", paramsList));
            }
            sb.AppendLine(")");

            if (isMain)
            {
                sb.AppendLine($"{Indent}{{");
                _indent++;
                if (node.Body != null) foreach (var stmt in node.Body.Statements) sb.Append(stmt.Accept(this));
                sb.AppendLine($"{Indent}return 0;");
                _indent--;
                sb.AppendLine($"{Indent}}}");
            }
            else
            {
                sb.Append(node.Body.Accept(this));
            }

            return sb.ToString();
        }

        public string Visit(FunctionCallNode node)
        {
            // Se chamar printf ou system, precisamos do stdio.h/stdlib.h
            if (node.Name.Contains("printf") || node.Name.Contains("system"))
            {
                _usesStdIo = true;
            }

            var cArgs = node.Arguments.Select(a => a.Accept(this));

            // Se o nome for console::printf, e for extern, o C espera apenas "printf"
            // Aqui você pode adicionar uma lógica para limpar o prefixo de funções nativas
            string cName = node.Name.Replace("::", "_");

            // Caso especial: se estivermos chamando um extern do C dentro da STL
            if (node.Name == "printf" || node.Name == "system") cName = node.Name;

            return $"{cName}({string.Join(", ", cArgs)})";
        }

        public string Visit(LiteralNode node)
        {
            if (node.TypeName == "string")
            {
                _usesTypes = true;
                return $"\"{node.Value}\"";
            }

            if (node.TypeName == "b8")
            {
                _usesTypes = true;
                return (bool)node.Value ? "true" : "false";
            }

            if (node.TypeName == "f32")
            {
                string val = node.Value.ToString()!.Replace(",", ".");
                return val.Contains('.') ? $"{val}f" : $"{val}.0f";
            }

            return node.Value.ToString()!.Replace(",", ".");
        }

        // --- Resto dos métodos mantidos iguais ---
        public string Visit(ProgramNode node)
        {
            var sb = new StringBuilder();
            foreach (var stmt in node.Statements)
                if (stmt is not UseNode) sb.Append(stmt.Accept(this));
            return sb.ToString();
        }

        public string Visit(ModuleNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"\n/* Module: {node.Name} */");
            foreach (var func in node.Functions)
            {
                func.ModuleOwner = node.Name;
                sb.Append(func.Accept(this));
            }
            return sb.ToString();
        }

        public string Visit(BlockNode node)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"{Indent}{{");
            _indent++;
            foreach (var stmt in node.Statements) sb.Append(stmt.Accept(this));
            _indent--;
            sb.AppendLine($"{Indent}}}");
            return sb.ToString();
        }

        public string Visit(VariableDeclarationNode node)
        {
            _usesTypes = true;
            string prefix = node.IsConstant ? "const " : "";
            return $"{Indent}{prefix}{ConvertType(node.Type)} {node.Name} = {node.Initializer.Accept(this)};\n";
        }

        public string Visit(AssignmentNode node) => $"{Indent}{node.Name} = {node.Expression.Accept(this)};\n";
        public string Visit(IdentifierNode node) => node.Name.Replace("::", "_");
        public string Visit(ReturnNode node) => $"{Indent}return {node.Expression.Accept(this)};\n";
        public string Visit(ExpressionStatementNode node) => $"{Indent}{node.Expression.Accept(this)};\n";
        public string Visit(UseNode node) => $"#include \"{node.Module}.h\"\n";
        public string Visit(BinaryExpressionNode node) { /* ... lógica de operadores ... */ return $"({node.Left.Accept(this)} + {node.Right.Accept(this)})"; } // Simplificado para o exemplo
        public string Visit(IfNode node) { return ""; } // Mantenha sua lógica original
        public string Visit(WhileNode node) { return ""; }
        public string Visit(ForNode node) { return ""; }
        public string Visit(UnaryExpressionNode node) { return ""; }
        public string Visit(InterpolatedStringNode node) => "";
        public string Visit(CastExpressionNode node) => $"(({ConvertType(node.TargetType)}){node.Expression.Accept(this)})";
    }
}